
import { Point } from 'atom'; // eslint-disable-line import/no-unresolved, no-unused-vars
import { Identifier, EmptyIdentifier } from 'dropdown-navigation-bar/lib/identifiers';
import { IdentifiersProvider } from 'dropdown-navigation-bar/lib/identifiersProvider';

const babelParser = require('@babel/parser');
// https://github.com/estree/estree

export function dropdownNavigationBarProviderServiceV1() {
    return BabelProvider;
}

/**
 * Provider uses Babel for parsing source code. It handles javascript, typescript and flow.
 */
export class BabelProvider extends IdentifiersProvider {
    /**
     * Holds esTree generated by Babel.
     * @type {object}
     */
    _esTree = null;

    /**
     * Holds instance of current Identifier. It's either TopScopeIdentifier,
     * a parent Identifier which can have children, or child Identifier.
     * @type {Identifier}
     */
    _currentIdentifier = null;

    /**
     * Holds instance of current EsTree node provider is processing.
     * @type {Object}
     */
    _currentEsTreeNode = null;
    
    /**
     * Returns true if provider can provide identifiers for given `textEditor`. Returns false if it cannot.
     * @param  {TextEditor}  textEditor
     * @return {Boolean}     true or false
     */
    static isSupported( textEditor ) {
        try {
            if( textEditor ) {
                if( textEditor.getRootScopeDescriptor().getScopesArray()[0] === 'source.js' ) {
                    return true;
                }
            }
        } catch( ex ) {
            console.error( 'BabelProvider::isSupported caught exception:', ex );
        }
        
        return false;
    }
    
    static getPriority() {
        return 10;
    }
    
    /**
     * @override
     */
    generateIdentifiers() {
        this._topScopeIdentifier.removeAllChildren();
        this.parse();
        this.processEsTree();

        console.debug(
            'BabelProvider finished',
            this._topScopeIdentifier
        );

        const checkForEmptyKind = ( identifier ) => {
            for( const child of identifier.getChildren() ) {
                checkForEmptyKind( child );
            }
            console.assert( identifier.getKind().length !== 0, 'Identifier has to have at least one kind!' );
        };
        checkForEmptyKind( this._topScopeIdentifier );

        this._emitter.emit(
            'did-generate-identifiers',
            { provider: this, identifiers: this._topScopeIdentifier }
        );
    }
    
    /**
     * @override
     */
    getTopScopeIdentifier() {
        if( !this._esTree ) {
            this.generateIdentifiers();
        }
        
        return this._topScopeIdentifier;
    }
    
    /**
     * @override
     */
    getIdentifiersForParentsDropbox( identifier ) {
        if( !this._esTree ) {
            this.generateIdentifiers();
        }
        
        if( identifier === null || identifier === undefined ) {
            identifier = this._topScopeIdentifier;
        }
        
        return [
            this._topScopeIdentifier,
            ...identifier.getChildren().filter( (ident) => {
                if( ident.isKind('class') ) {
                    return true;
                }
                return false;
            })
        ];
    }

    /**
     * @override
     */
    getIdentifiersForChildrenDropbox( identifier ) {
        if( !this._esTree ) {
            this.generateIdentifiers();
        }
        
        if( identifier === null || identifier === undefined ) {
            identifier = this._topScopeIdentifier;
        }

        if( identifier instanceof EmptyIdentifier ) {
            identifier = identifier.getParent();
        }
        
        if( identifier.isKind('function')
            || identifier.isKind('method')
            || identifier.isKind('constructor')
            || identifier.isKind('get')
            || identifier.isKind('set')
        ) {
            identifier = identifier.getParent();
        }

        return [
            new EmptyIdentifier( identifier ),
            ...identifier.getChildren().filter( (ident) => {
                if( ident.isKind('variable')
                    || ident.isKind('function')
                    || ident.isKind('method')
                    || ident.isKind('constructor')
                    || ident.isKind('get')
                    || ident.isKind('set')
                    || ident.isKind('property')
                    || ident.isKind('unimplemented')
                    || ident.isKind('export all')
                    || ident.isKind('multiple')
                ) {
                    return true;
                }
                return false;
            })
        ];
    }
    
    /**
     * @override
     */
    getIdentifierForPosition( position ) {
        if( !this._esTree ) {
            this.generateIdentifiers();
        }
        
        const searchInChildren = (parent) => {
            if( parent.isKind('function')
                || parent.isKind('method')
                || parent.isKind('constructor')
                || parent.isKind('get')
                || parent.isKind('set')
            ) return parent;
            
            for( const child of parent.getChildren() ) {
                const startPosition = child.getStartPosition();
                const endPosition = child.getEndPosition();

                if( startPosition && endPosition ) {
                    if( startPosition.isGreaterThan( endPosition ) ) {
                        console.warn('Identifier\'s startPosition is after endPosition!', child );
                    } else {
                        if( position.isGreaterThanOrEqual( startPosition )
                            && position.isLessThanOrEqual( endPosition ) ) {
                            if( child.hasChildren() ) {
                                return searchInChildren( child );
                            }

                            return child;
                        }
                    }
                }
            }

            return parent;
        };

        return searchInChildren( this._topScopeIdentifier );
    }

    /**
     * Parses source code from TextEditor with Babel.
     *
     * @private
     */
    parse() {
        const parserOptions = {
            errorRecovery: true,
            sourceType: 'module',
            plugins: [
                'asyncGenerators',
                'bigInt',
                'classProperties',
                'classPrivateProperties',
                'classPrivateMethods',
                [ 'decorators', { decoratorsBeforeExport: false } ],
                'doExpressions',
                'dynamicImport',
                'exportDefaultFrom',
                'exportNamespaceFrom',
                'functionBind',
                'functionSent',
                'importMeta',
                'logicalAssignment',
                'nullishCoalescingOperator',
                'numericSeparator',
                'objectRestSpread',
                'optionalCatchBinding',
                'optionalChaining',
                'partialApplication',
                //'pipelineOperator',
                'throwExpressions',
                'topLevelAwait'
            ]
        };

        try {
            this._esTree = babelParser.parse( this._textEditor.getBuffer().getText(), parserOptions );
            console.info('BabelProvider::parse esTree:', this._esTree);
        } catch( error ) {
            console.error( 'BabelProvider::parse caught exception:', error );
            this._esTree = null;
        }
    }

    /**
     * Processes EsTree generated by Babel, if parsing produced one.
     *
     * @private
     */
    processEsTree() {
        if( !this._esTree ) return;

        switch( this._esTree.type ) {
        case 'File':
            this.processFile( this._esTree, this._topScopeIdentifier );
            break;
        default:
            console.warn( 'BabelProvider::processEsTree: Unknown node type!', this._esTree.type );
            console.info( this._esTree );
        }
    }

    /*
        File:
        .comments   {Array}
        .end        {number}
        .errors     {Array}
        .loc        SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .program    {Node}
        .start      {number}
        .type       'File'
     */
    processFile( node, currentIdentifier ) {
        console.assert( node.type === 'File', 'Wrong node type!' );

        this.processProgram( node.program, currentIdentifier );
    }

    /*
        Program {
            body: [ Statement | ModuleDeclaration ];
            loc: SourceLocation | null;
            sourceType: "script" | "module";
            type: string;
        }

        Program:
        .body           {Array}
        .directives     {Array}
        .end            {number}
        .interpreter    {null}
        .loc            SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .sourceType     {string}
        .start          {number}
        .type           'Program'
     */
    processProgram( node, currentIdentifier ) {
        console.assert( node.type === 'Program', 'Wrong node type!' );

        for( const body of node.body ) {
            if( !this.processStatement( body, currentIdentifier ) ) {
                if( !this.processModuleDeclaration( body, currentIdentifier ) ) {
                    console.warn( 'BabelProvider::processProgram: Unknown program.body.type!', body.type );
                    console.info( 'Program', node );
                    console.info( 'esTree:', this._esTree );
                }
            }
        }
    }

    /*
        ModuleDeclaration: ExportAllDeclaration
            | ExportDefaultDeclaration
            | ExportNamedDeclaration
            | ImportDeclaration;
     */
    processModuleDeclaration( node, currentIdentifier ) {
        switch( node.type ) {
        case 'ExportAllDeclaration':
            this.processExportAllDeclaration( node, currentIdentifier );
            break;
        case 'ExportDefaultDeclaration':
            this.processExportDefaultDeclaration( node, currentIdentifier );
            break;
        case 'ExportNamedDeclaration':
            this.processExportNamedDeclaration( node, currentIdentifier );
            break;
        case 'ImportDeclaration':
            this.processImportDeclaration( node, currentIdentifier );
            break;
        default:
            return false;
        }
        return true;
    }

    /*
        Statement: BlockStatement( FunctionBody )
            | BreakStatement
            | ContinueStatement
            | DebuggerStatement
            | Declaration( ClassDeclaration | FunctionDeclaration | VariableDeclaration )
            | DoWhileStatement
            | EmptyStatement
            | ExpressionStatement
            | ForInStatement
            | ForOfStatement
            | ForStatement
            | IfStatement
            | LabeledStatement
            | ReturnStatement
            | SwitchStatement
            | ThrowStatement
            | TryStatement
            | WhileStatement
            | WithStatement;
     */
    processStatement( node, currentIdentifier ) {
        //console.info(`BabelProvider::processStatement: ${node.type}:`, node);
        if( this.processDeclaration( node, currentIdentifier ) ) {
            return true;
        }

        switch( node.type ) {
        case 'FunctionBody':
            break;
        case 'ExpressionStatement':
            this.tryProcessModuleExports( node, currentIdentifier );
            break;
        case 'BreakStatement':
        case 'ContinueStatement':
        case 'DebuggerStatement':
        case 'DoWhileStatement':
        case 'EmptyStatement':
        case 'ForInStatement':
        case 'ForOfStatement':
        case 'ForStatement':
        case 'IfStatement':
        case 'LabeledStatement':
        case 'ReturnStatement':
        case 'SwitchStatement':
        case 'ThrowStatement':
        case 'TryStatement':
        case 'WhileStatement':
        case 'WithStatement':
            console.info(`BabelProvider::processStatement: ${node.type} is ignored.`, node);
            break;
        default:
            return false;
        }
        return true;
    }
    
    tryProcessModuleExports( node, parentIdentifier ) {
        // module.exports.two.three.four.last variable names are stored
        // as last -> four -> three -> two -> exports -> module
        // so we need to call recurrently until we get to module and exports part
        const checkIsModuleExports = ( inNode ) => {
            if( inNode
                && inNode.type
                && inNode.type === 'MemberExpression' ) {
                if( inNode.object
                    && inNode.object.type
                    && inNode.object.type === 'Identifier'
                    && inNode.object.name
                    && inNode.object.name === 'module'
                    && inNode.property
                    && inNode.property.type
                    && inNode.property.type === 'Identifier'
                    && inNode.property.name
                    && inNode.property.name === 'exports' ) {
                    return inNode;
                } else if( inNode.object
                            && inNode.object.type
                            && inNode.object.type === 'MemberExpression' ) {
                    return checkIsModuleExports( inNode.object );
                }
                return null;
            }
            return null;
        };
        
        if( node && node.expression && node.expression.left
            && checkIsModuleExports( node.expression.left ) ) {
            // empty
        } else {
            return false;
        }
       
        const moduleExportsIdentifier = this.addNewIdentifier( parentIdentifier );
        moduleExportsIdentifier.setName('module.exports');
        moduleExportsIdentifier.addKind('export').addKind('variable');
        
        if( node.expression.right ) {
            switch( node.expression.right.type ) {
            case 'ClassExpression':
                this.processClassExpression( node.expression.right, parentIdentifier, moduleExportsIdentifier );
                break;
            case 'FunctionExpression':
                this.processFunctionExpression( node.expression.right, parentIdentifier, moduleExportsIdentifier );
                break;
            default:
                //console.log('tryProcessModuleExports node.expression.right.type:', node.expression.right.type, node );
                // nothing
            }
        }
        
        this.setPositionsFromNode( node, moduleExportsIdentifier );
        
        //console.log(moduleExportsIdentifier);
        return true;
    }
    
    /*
        Declaration: ClassDeclaration
            | FunctionDeclaration
            | VariableDeclaration;
     */
    processDeclaration( node, parentIdentifier, currentIdentifier ) {
        switch( node.type ) {
        case 'ClassDeclaration':
            this.processClassDeclaration( node, parentIdentifier, currentIdentifier );
            break;
        case 'FunctionDeclaration':
            this.processFunctionDeclaration( node, parentIdentifier, currentIdentifier );
            break;
        case 'VariableDeclaration':
            this.processVariableDeclaration( node, parentIdentifier, currentIdentifier );
            break;
        default:
            return false;
        }
        return true;
    }

    /*
        ExportAllDeclaration <: ModuleDeclaration {
            type: "ExportAllDeclaration";
            source: Literal;
            loc: SourceLocation | null;
            exported: Identifier | null;
        }
     */
    processExportAllDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportAllDeclaration', 'Wrong node type!' );

        const exportAllIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, exportAllIdentifier );
        if( node.exported ) {
            exportAllIdentifier.setName( this.getIdentifierAsString( node.exported ) );
        } else {
            exportAllIdentifier.setName('unnamed export');
        }
        exportAllIdentifier.addKind('export all');
    }

    /*
        ExportDefaultDeclaration <: ModuleDeclaration {
            type: "ExportDefaultDeclaration";
            loc: SourceLocation | null;
            declaration: AnonymousDefaultExportedFunctionDeclaration
                | FunctionDeclaration
                | AnonymousDefaultExportedClassDeclaration
                | ClassDeclaration
                | Expression;
        }
     */
    processExportDefaultDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportDefaultDeclaration', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        if( node.declaration ) {
            switch( node.declaration.type ) {
            case 'ClassDeclaration':
                this.processClassDeclaration( node.declaration, parentIdentifier, identifier );
                break;
            default:
                console.warn( 'BabelProvider::processExportDefaultDeclaration: Unknown declaration type!', node.declaration.type );
                console.info( 'declaration', node.declaration );
            }
        }
        identifier.addKind('export');
        identifier.addKind('default');
    }

    /*
        ExportNamedDeclaration <: ModuleDeclaration {
            type: "ExportNamedDeclaration";
            declaration: Declaration | null;
            specifiers: [ ExportSpecifier ];
            source: Literal | null;
            loc: SourceLocation | null;
        }

        ExportNamedDeclaration:
        .declaration        {Node}
        .end                {number}
        .loc                SourceLocation{start:{line,column}, end:{line,column}, source: string|null}
        .source             {Literal|null}
        .specifiers         {Array}
        .start              {number}
        .trailingComments   ['CommentBlock']
        .type               'ExportNamedDeclaration'
     */
    processExportNamedDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportNamedDeclaration', 'Wrong node type!' );

        const exportedIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, exportedIdentifier );
        exportedIdentifier.addKind('export');
        if( node.specifiers.length > 0 ) {
            exportedIdentifier.addKind('multiple');
            for( const specifier of node.specifiers ) {
                const identifier = this.addNewIdentifier( exportedIdentifier );
                this.processExportSpecifier( specifier, exportedIdentifier, identifier );
            }
        }

        if( node.declaration !== null ) {
            this.processDeclaration( node.declaration, parentIdentifier, exportedIdentifier );
        }
    }

    /*
        ExportSpecifier <: ModuleSpecifier {
            type: "ExportSpecifier";
            exported: Identifier;
            loc: SourceLocation | null;
            local: Identifier;
        }
     */
    processExportSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExportSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.addKind('variable');
        identifier.addKind('export');
        this.processIdentifier( node.local, parentIdentifier, identifier );
        identifier.getAdditionalDataMap().set( 'exported', this.getIdentifierName( node.exported ) );
    }

    /*
        VariableDeclaration <: Declaration {
            type: "VariableDeclaration";
            declarations: [ VariableDeclarator ];
            kind: "var" | "let" | "const";
            loc: SourceLocation | null;
        }
     */
    processVariableDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'VariableDeclaration', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        if( node.declarations > 1 ) {
            identifier.addKind('multiple');
            for( const variableDeclarator of node.declarations ) {
                const variableIdentifier = this.addNewIdentifier( parentIdentifier );
                this.processVariableDeclarator( variableDeclarator, identifier, variableIdentifier );
                variableIdentifier.addKind( node.kind );
                variableIdentifier.addKind('variable');
            }
        } else {
            this.processVariableDeclarator( node.declarations[0], parentIdentifier, identifier );
            identifier.addKind( node.kind );
            identifier.addKind('variable');
        }
    }

    /*
        VariableDeclarator <: Node {
            type: "VariableDeclarator";
            id: Pattern;
            init: Expression | null;
            loc: SourceLocation | null;
        }
     */
    processVariableDeclarator( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'VariableDeclarator', 'Wrong node type!' );

        return this.processPattern( node.id, parentIdentifier, currentIdentifier );
    }

    /*
        ClassDeclaration <: Class, Declaration {
            type: "ClassDeclaration";
            id: Identifier;
            loc: SourceLocation | null;
            superClass: Expression | null;
            body: ClassBody;
        }
     */
    processClassDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ClassDeclaration', 'Wrong node type!' );

        const classIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        classIdentifier.addKind('class');
        this.setPositionsFromNode( node, classIdentifier );
        this.processIdentifier( node.id, parentIdentifier, classIdentifier );
        this.processClassBody( node.body, parentIdentifier, classIdentifier );
    }
    
    /*
        ClassExpression <: Class, Expression {
            type: "ClassExpression";
            loc: SourceLocation | null;
            id: Identifier | null;
            superClass: Expression | null;
            body: ClassBody;
        }
     */
    processClassExpression( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ClassExpression', 'Wrong node type!' );
        
        const classIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        classIdentifier.addKind('class');
        this.processIdentifier( node.id, parentIdentifier, classIdentifier );
        this.processClassBody( node.body, parentIdentifier, classIdentifier );
    }

    /*
        ClassBody <: Node {
            type: "ClassBody";
            body: [ MethodDefinition | PropertyDefinition ];
            loc: SourceLocation | null;
        }
     */
    processClassBody( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ClassBody', 'Wrong node type!' );
        console.assert( currentIdentifier !== undefined, 'currentIdentifier in ClassBody cannot be undefined but must point to class Identifier!' );
        //this.setEndPositionFromNode( node, currentIdentifier );

        for( const member of node.body ) {
            switch( member.type ) {
            case 'MethodDefinition':
            case 'ClassMethod': { // That's how it's named in Babel
                const methodIdentifier = this.addNewIdentifier( currentIdentifier );
                this.processMethodDefinition( member, methodIdentifier );
            } break;
            case 'PropertyDefinition':
            case 'ClassProperty': { // That's how it's named in Babel
                const propertyIdentifier = this.addNewIdentifier( currentIdentifier );
                this.processPropertyDefinition( member, propertyIdentifier );
            } break;
            default:
                console.warn( 'BabelProvider::processClassBody: Unknown class member type!', member.type );
                console.info( 'ClassBody', node );
            }
        }
    }

    /*
        MethodDefinition <: Node {
            type: "MethodDefinition";
            key: Expression;
            value: FunctionExpression;
            kind: "constructor" | "method" | "get" | "set";
            computed: boolean;
            static: boolean;
            loc: SourceLocation | null;
        }

        BabelClassMethod <: MethodDefinition {
            type: "ClassMethod";
            kind: "constructor" | "method" | "get" | "set";
            key: for computed=true [ Expression ]
            key: for computed=false [ Identifier | Literal ];
            params: [ LVal ];
            body: BlockStatement;
            computed: boolean;
            static: boolean | null;
            abstract: boolean
            access: [ "public" | "private" | "protected" ] | null;
            accessibility: [ "public" | "private" | "protected" ] | null;
            async: boolean;
            decorators: [ Decorator ] | null;
            generator: boolean;
            optional: boolean | null;
            returnType: TypeAnnotation | TSTypeAnnotation | Noop | null;
            typeParameters: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
        }
     */
    /**
     * Processes method definition found in class body.
     * @param  {object}     node             Method definition estree node.
     * @param  {Identifier} methodIdentifier Identifier owned by class this method belongs to.
     */
    processMethodDefinition( node, methodIdentifier ) {
        console.assert( node.type === 'MethodDefinition' || node.type === 'ClassMethod', 'Wrong node type!' );
        console.assert( methodIdentifier !== undefined, 'You must provide methodIdentifier, it won\'t be created for you!' );

        this.setPositionsFromNode( node, methodIdentifier );
        methodIdentifier.addKind( node.kind );
        if( node.computed ) {
            methodIdentifier.addKind('computed');
            // TODO: node.key is Expression
            methodIdentifier.setName('Expression').addKind('unimplemented');
        } else {
            switch( node.key.type ) {
            case 'Identifier':
                this.processIdentifier( node.key, {}, methodIdentifier );
                break;
            case 'Literal':
                methodIdentifier.setName('Literal').addKind('unimplemented');
                break;
            default:
                console.warn( 'BabelProvider::processMethodDefinition: Unknown class member key type!', node.key.type );
                console.info( 'MethodDefinition', node );
            }
        }
        node.static && methodIdentifier.addKind('static');
        node.abstract && methodIdentifier.addKind('abstract');
        node.access && methodIdentifier.addKind( node.access );
        node.accessibility && methodIdentifier.addKind( node.accessibility );
        node.async && methodIdentifier.addKind('async');
        node.generator && methodIdentifier.addKind('generator');
        node.optional && methodIdentifier.addKind('optional');

        for( const paramNode of node.params ) {
            const paramIdentifier = this.addNewIdentifier( methodIdentifier );
            paramIdentifier.addKind('param');
            this.processPattern( paramNode, methodIdentifier, paramIdentifier );
        }
        
        // TODO: decorators
        // TODO: returnType
        // TODO: typeParameters
    }

    /*
        PropertyDefinition <: Node {
            type: "PropertyDefinition";
            key: Expression | PrivateIdentifier;
            value: Expression | null;
            computed: boolean;
            static: boolean;
        }

        BabelClassProperty <: PropertyDefinition {
            type: "ClassProperty";
            key: Identifier | StringLiteral | NumericLiteral | Expression;
            value: Expression | null;
            typeAnnotation: TypeAnnotation | TSTypeAnnotation | Noop | null;
            decorators: Array<Decorator> | null;
            computed: boolean;
            abstract: boolean | null;
            accessibility: [ "public" | "private" | "protected" ] | null;
            definite: boolean | null;
            optional: boolean | null;
            readonly: boolean | null;
            static: boolean | null;
        }

        PrivateIdentifier <: Node {
            type: "PrivateIdentifier";
            name: string;
        }

        MemberExpression {
            property: Expression | PrivateIdentifier;
        }
     */
    /**
      * Processes property definition found in class body.
      * @param  {object}     node               Property definition estree node.
      * @param  {Identifier} propertyIdentifier Identifier owned by class this property belongs to.
      */
    processPropertyDefinition( node, propertyIdentifier ) {
        console.assert( node.type === 'PropertyDefinition' || node.type === 'ClassProperty', 'Wrong node type!' );
        console.assert( propertyIdentifier !== undefined, 'You must provide propertyIdentifier, it won\'t be created for you!' );

        this.setPositionsFromNode( node, propertyIdentifier );
        propertyIdentifier.addKind('property');
        switch( node.key.type ) {
        case 'Identifier':
            this.processIdentifier( node.key, {}, propertyIdentifier );
            break;
        case 'StringLiteral':
            propertyIdentifier.setName('StringLiteral').addKind('unimplemented');
            break;
        case 'NumericLiteral':
            propertyIdentifier.setName('NumericLiteral').addKind('unimplemented');
            break;
        case 'Expression':
            propertyIdentifier.setName('Expression').addKind('unimplemented');
            break;
        default:
            console.warn( 'BabelProvider::processPropertyDefinition: Unknown class member key type!', node.key.type );
            console.info( 'PropertyDefinition', node );
        }
        node.computed && propertyIdentifier.addKind('computed');
        node.abstract && propertyIdentifier.addKind('abstract');
        node.accessibility && propertyIdentifier.addKind( node.accessibility );
        node.definite && propertyIdentifier.addKind('definite');
        node.optional && propertyIdentifier.addKind('optional');
        node.readonly && propertyIdentifier.addKind('readonly');
        node.static && propertyIdentifier.addKind('static');

        // TODO: decorators
        // TODO: typeAnnotation
    }

    /*
        FunctionDeclaration <: Function, Declaration {
            type: "FunctionDeclaration";
            id: Identifier;
            loc: SourceLocation | null;
            async: boolean;
            generator: boolean;
            params: [ Pattern ];
            body: FunctionBody;
        }
     */
    processFunctionDeclaration( node, parentIdentifier ) {
        console.assert( node.type === 'FunctionDeclaration', 'Wrong node type!' );

        this.processFunction( node, parentIdentifier );
    }
    
    /*
        FunctionExpression <: Function, Expression {
            type: "FunctionExpression";
            loc: SourceLocation | null;
            async: boolean;
            generator: boolean;
            id: Identifier | null;
            params: [ Pattern ];
            body: FunctionBody;
        }
     */
    processFunctionExpression( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'FunctionExpression', 'Wrong node type!' );

        this.processFunction( node, parentIdentifier, currentIdentifier );
    }
    
    /*
        Function <: Node {
            async: boolean;
            generator: boolean;
            id: Identifier | null;
            params: [ Pattern ];
            body: FunctionBody;
            loc: SourceLocation | null;
        }
     */
    processFunction( node, parentIdentifier, currentIdentifier ) {
        const functionIdentifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        
        functionIdentifier.addKind('function');
        
        if( node.id ) {
            this.processIdentifier( node.id, parentIdentifier, functionIdentifier );
        } else {
            functionIdentifier.setName('(anonymous)');
            functionIdentifier.addKind('anonymous');
        }
        
        this.setPositionsFromNode( node, functionIdentifier );
        
        if( node.async ) functionIdentifier.addKind('async');
        if( node.generator ) functionIdentifier.addKind('generator');
        
        for( const paramNode of node.params ) {
            const paramIdentifier = this.addNewIdentifier( functionIdentifier );
            paramIdentifier.addKind('param');
            this.processPattern( paramNode, functionIdentifier, paramIdentifier );
        }
    }

    /*
        ImportDeclaration <: ModuleDeclaration {
            type: "ImportDeclaration";
            source: Literal;
            specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];
            loc: SourceLocation | null;
        }
     */
    processImportDeclaration( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportDeclaration', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.addKind('import');
        identifier.setName('ImportDeclaration');
        for( const specifier of node.specifiers ) {
            switch( specifier.type ) {
            case 'ImportSpecifier':
                this.processImportSpecifier( specifier, parentIdentifier, identifier );
                break;
            case 'ImportDefaultSpecifier':
                this.processImportDefaultSpecifier( specifier, parentIdentifier, identifier );
                break;
            case 'ImportNamespaceSpecifier':
                this.processImportNamespaceSpecifier( specifier, parentIdentifier, identifier );
                break;
            default:
                console.warn( 'BabelProvider::processImportDeclaration: Unknown specifier.type!', specifier.type );
                console.info( 'Program', node );
            }
        }
    }

    /*
        ImportDefaultSpecifier <: ModuleSpecifier {
            type: "ImportDefaultSpecifier";
            loc: SourceLocation | null;
            local: Identifier;
        }
    */
    processImportDefaultSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportDefaultSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        this.processIdentifier( node.local, parentIdentifier, identifier );
        identifier.addKind('variable');
    }

    /*
        ImportExpression <: Expression {
            type: "ImportExpression";
            source: Expression;
            loc: SourceLocation | null;
        }
    */
    processImportExpression( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportExpression', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.setName('ImportExpression').addKind('unimplemented');
    }

    /*
        ImportNamespaceSpecifier <: ModuleSpecifier {
            type: "ImportNamespaceSpecifier";
            loc: SourceLocation | null;
            local: Identifier;
        }
    */
    processImportNamespaceSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportNamespaceSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        this.processIdentifier( node.local, parentIdentifier, identifier );
        identifier.addKind('variable');
    }

    /*
        ImportSpecifier <: ModuleSpecifier {
            type: "ImportSpecifier";
            imported: Identifier;
            loc: SourceLocation | null;
            local: Identifier;
        }
    */
    processImportSpecifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ImportSpecifier', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        this.processIdentifier( node.imported, parentIdentifier, identifier );
        identifier.getAdditionalDataMap().set( 'local', this.getIdentifierName( node.local ) );
        identifier.addKind('variable');
    }

    /*
        ExpressionStatement <: Statement {
            type: "ExpressionStatement";
            expression: Expression;
            loc: SourceLocation | null;
        }
     */
    processExpressionStatement( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ExpressionStatement', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.setName('ExpressionStatement').addKind('unimplemented');
    }

    /*
        Pattern: ArrayPattern
            | AssignmentPattern
            | Identifier
            | MemberExpression
            | ObjectPattern
            | RestElement
     */
    processPattern( node, parentIdentifier, currentIdentifier ) {
        switch( node.type ) {
        case 'Identifier':
            this.processIdentifier( node, parentIdentifier, currentIdentifier );
            break;
        case 'ArrayPattern':
            this.processArrayPattern( node, parentIdentifier, currentIdentifier );
            break;
        case 'AssignmentPattern':
            this.processAssignmentPattern( node, parentIdentifier, currentIdentifier );
            break;
        case 'MemberExpression':
            this.processMemberExpression( node, parentIdentifier, currentIdentifier );
            break;
        case 'ObjectPattern':
            this.processObjectPattern( node, parentIdentifier, currentIdentifier );
            break;
        case 'RestElement':
            this.processRestElement( node, parentIdentifier, currentIdentifier );
            break;
        default:
            console.warn( 'BabelProvider::processPattern: Unknown Pattern type!', node.type );
            console.info( node );
        }
    }

    /*
        Identifier <: Expression, Pattern {
            type: "Identifier";
            name: string;
            loc: SourceLocation | null;
        }
     */
    processIdentifier( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'Identifier', 'Wrong node type!' );

        currentIdentifier.setName( node.name );
        this.setStartPositionFromNode( node, currentIdentifier );
    }

    getIdentifierName( node ) {
        console.assert( node.type === 'Identifier', 'Wrong node type!' );

        return node.name;
    }

    /*
        ArrayPattern <: Pattern {
            type: "ArrayPattern";
            elements: [ Pattern | null ];
            loc: SourceLocation | null;
        }
     */
    processArrayPattern( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ArrayPattern', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.setName( 'ArrayPattern' ).addKind('unimplemented');
    }

    /*
        AssignmentPattern <: Pattern {
            type: "AssignmentPattern";
            left: Pattern;
            right: Expression;
            loc: SourceLocation | null;
        }
     */
    processAssignmentPattern( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'AssignmentPattern', 'Wrong node type!' );
        
        if( !currentIdentifier ) debugger;
        
        this.setPositionsFromNode( node, currentIdentifier );
        this.processPattern( node.left, parentIdentifier, currentIdentifier );
        // TODO: get value from right side of AssignmentPattern node...
    }

    /*
        MemberExpression <: Expression, Pattern, ChainElement {
            type: "MemberExpression";
            object: Expression | Super;
            property: Expression;
            computed: boolean;
            loc: SourceLocation | null;
            optional: boolean;
        }
     */
    processMemberExpression( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'MemberExpression', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.setName( 'MemberExpression' ).addKind('unimplemented');
    }

    /*
        ObjectPattern <: Pattern {
            type: "ObjectPattern";
            properties: [ AssignmentProperty | RestElement ];
            loc: SourceLocation | null;
        }
     */
    processObjectPattern( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'ObjectPattern', 'Wrong node type!' );

        const identifier = currentIdentifier || this.addNewIdentifier( parentIdentifier );
        this.setPositionsFromNode( node, identifier );
        identifier.setName( 'ObjectPattern' ).addKind('unimplemented');
    }

    /*
        RestElement <: Pattern {
            type: "RestElement";
            argument: Pattern;
            loc: SourceLocation | null;
        }
     */
    processRestElement( node, parentIdentifier, currentIdentifier ) {
        console.assert( node.type === 'RestElement', 'Wrong node type!' );

        console.debug('restPattern', node);
        if( !currentIdentifier ) debugger;

        this.setPositionsFromNode( node, currentIdentifier );
        this.processPattern( node.argument, parentIdentifier, currentIdentifier );
        currentIdentifier.setName( `...${currentIdentifier.getName()}` );
    }

    /**
     * Adds a new Identifier to `parentIdentifier` and returns the newly added Identifier.
     * @param {Identifier} parentIdentifier
     * @return {Identifier} Returns the newly added identifier.
     *
     * @throws {Error} When `parentIdentifier` is not given.
     */
    addNewIdentifier( parentIdentifier ) {
        if( !parentIdentifier ) {
            throw new Error('"parentIdentifier" is required argument.');
        }

        const identifier = new Identifier({ textEditor: this._textEditor, parent: parentIdentifier });
        parentIdentifier.addChild( identifier );
        return identifier;
    }

    /**
     * Sets startPosition of `identifier` to start position from given `node`.
     * @param  {object}     node       AST Babel node
     * @param  {Identifier} identifier Identifier which we will assing positions to.
     */
    setStartPositionFromNode( node, identifier ) {
        identifier.setStartPosition( new Point( node.loc.start.line - 1, node.loc.start.column ) );
    }

    /**
     * Sets endPosition of `identifier` to end position from given `node`.
     * @param  {object}     node       AST Babel node
     * @param  {Identifier} identifier Identifier which we will assing positions to.
     */
    setEndPositionFromNode( node, identifier ) {
        // Babel counts rows from 1
        identifier.setEndPosition( new Point( node.loc.end.line - 1, node.loc.end.column ) );
    }

    /**
     * Sets `identifier`'s startPosition and endPosition to positions from given `node`.
     * @param  {object}     node       AST Babel node
     * @param  {Identifier} identifier Identifier which we will assing positions to.
     */
    setPositionsFromNode( node, identifier ) {
        this.setStartPositionFromNode( node, identifier );
        this.setEndPositionFromNode( node, identifier );
    }
}



/*

Declaration: ClassDeclaration | FunctionDeclaration | VariableDeclaration;
Expression: ArrayExpression
    | ArrowFunctionExpression
    | AssignmentExpression
    | AwaitExpression
    | BinaryExpression
    | CallExpression
    | ChainExpression
    | ClassExpression
    | ConditionalExpression
    | FunctionExpression
    | Identifier
    | ImportExpression
    | Literal
    | LogicalExpression
    | MemberExpression
    | MetaProperty
    | NewExpression
    | ObjectExpression
    | SequenceExpression
    | TaggedTemplateExpression
    | TemplateLiteral
    | ThisExpression
    | UnaryExpression
    | UpdateExpression
    | YieldExpression
ModuleDeclaration: ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration;
Pattern: ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement;
BlockStatement: FunctionBody
Statement: BlockStatement( FunctionBody )
    | BreakStatement
    | ContinueStatement
    | DebuggerStatement
    | Declaration( ClassDeclaration | FunctionDeclaration | VariableDeclaration )
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | IfStatement
    | LabeledStatement
    | ReturnStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | WithStatement;

AnonymousDefaultExportedClassDeclaration <: Class {
    type: "ClassDeclaration";
    id: null;
    superClass: Expression | null;
    body: ClassBody;
    loc: SourceLocation | null;
}
AnonymousDefaultExportedFunctionDeclaration <: Function {
    type: "FunctionDeclaration";
    id: null;
    async: boolean;
    generator: boolean;
    params: [ Pattern ];
    body: FunctionBody;
    loc: SourceLocation | null;
}
ArrayExpression <: Expression {
    type: "ArrayExpression";
    elements: [ Expression | SpreadElement | null ];
    loc: SourceLocation | null;
}
ArrayPattern <: Pattern {
    type: "ArrayPattern";
    elements: [ Pattern | null ];
    loc: SourceLocation | null;
}
ArrowFunctionExpression <: Function, Expression {
    type: "ArrowFunctionExpression";
    body: FunctionBody | Expression;
    expression: boolean;
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
}
AssignmentExpression <: Expression {
    type: "AssignmentExpression";
    operator: AssignmentOperator;
    left: Pattern;
    right: Expression;
    loc: SourceLocation | null;
}
AssignmentOperator {
    "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=" | "**="
}
AssignmentPattern <: Pattern {
    type: "AssignmentPattern";
    left: Pattern;
    right: Expression;
    loc: SourceLocation | null;
}
AssignmentProperty <: Property {
    type: "Property"; // inherited
    value: Pattern;
    kind: "init";
    key: Expression;
    method: boolean;
    shorthand: boolean;
    computed: boolean;
    loc: SourceLocation | null;
}
AwaitExpression <: Expression {
    type: "AwaitExpression";
    argument: Expression;
    loc: SourceLocation | null;
}
BigIntLiteral <: Literal {
    bigint: string;
}
BinaryExpression <: Expression {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression;
    right: Expression;
    loc: SourceLocation | null;
}
BinaryOperator {
    "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "|" | "^" | "&" | "in" | "instanceof" | "**"
}
BlockStatement <: Statement {
    type: "BlockStatement";
    body: [ Statement ];
    loc: SourceLocation | null;
}
BreakStatement <: Statement {
    type: "BreakStatement";
    label: Identifier | null;
    loc: SourceLocation | null;
}
CallExpression <: Expression, ChainElement {
    type: "CallExpression";
    callee: Expression | Super;
    arguments: [ Expression | SpreadElement ];
    loc: SourceLocation | null;
    optional: boolean;
}
CatchClause <: Node {
    type: "CatchClause";
    param: Pattern | null;
    body: BlockStatement;
    loc: SourceLocation | null;
}
ChainElement <: Node {
    optional: boolean;
    loc: SourceLocation | null;
}
ChainExpression <: Expression {
    type: "ChainExpression";
    expression: ChainElement;
    loc: SourceLocation | null;
}
Class <: Node {
    id: Identifier | null;
    superClass: Expression | null;
    body: ClassBody;
    loc: SourceLocation | null;
}
ClassBody <: Node {
    type: "ClassBody";
    body: [ MethodDefinition | PropertyDefinition ];
    loc: SourceLocation | null;
}
PropertyDefinition <: Node {
    type: "PropertyDefinition";
    key: Expression | PrivateIdentifier;
    value: Expression | null;
    computed: boolean;
    static: boolean;
}
PrivateIdentifier <: Node {
    type: "PrivateIdentifier";
    name: string;
}
MemberExpression {
    property: Expression | PrivateIdentifier;
}
    BabelClassProperty <: PropertyDefinition {
        type: "ClassProperty";
        computed: boolean;
        key: Expression | PrivateIdentifier;
        static: boolean;
        value: Expression | null;
    }
    BabelClassMethod <: MethodDefinition {
        type: "ClassMethod";
        async: boolean;
        body: Node;
        computed: boolean;
        generator: boolean;
        key: Node;
        kind: [ "method" ];
        params: [ Node ];
        static: boolean;
    }
ClassDeclaration <: Class, Declaration {
    type: "ClassDeclaration";
    id: Identifier;
    loc: SourceLocation | null;
    superClass: Expression | null;
    body: ClassBody;
}
ClassExpression <: Class, Expression {
    type: "ClassExpression";
    loc: SourceLocation | null;
    id: Identifier | null;
    superClass: Expression | null;
    body: ClassBody;
}
ConditionalExpression <: Expression {
    type: "ConditionalExpression";
    test: Expression;
    alternate: Expression;
    consequent: Expression;
    loc: SourceLocation | null;
}
ContinueStatement <: Statement {
    type: "ContinueStatement";
    label: Identifier | null;
    loc: SourceLocation | null;
}
DebuggerStatement <: Statement {
    type: "DebuggerStatement";
    loc: SourceLocation | null;
}
Declaration <: Statement {
    loc: SourceLocation | null;
}
Directive <: Node {
    type: "ExpressionStatement";
    expression: Literal;
    directive: string;
    loc: SourceLocation | null;
}
DoWhileStatement <: Statement {
    type: "DoWhileStatement";
    body: Statement;
    test: Expression;
    loc: SourceLocation | null;
}
EmptyStatement <: Statement {
    type: "EmptyStatement";
    loc: SourceLocation | null;
}
ExportAllDeclaration <: ModuleDeclaration {
    type: "ExportAllDeclaration";
    source: Literal;
    loc: SourceLocation | null;
    exported: Identifier | null;
}
ExportDefaultDeclaration <: ModuleDeclaration {
    type: "ExportDefaultDeclaration";
    loc: SourceLocation | null;
    declaration: AnonymousDefaultExportedFunctionDeclaration | FunctionDeclaration | AnonymousDefaultExportedClassDeclaration | ClassDeclaration | Expression;
}
ExportNamedDeclaration <: ModuleDeclaration {
    type: "ExportNamedDeclaration";
    declaration: Declaration | null;
    specifiers: [ ExportSpecifier ];
    source: Literal | null;
    loc: SourceLocation | null;
}
ExportSpecifier <: ModuleSpecifier {
    type: "ExportSpecifier";
    exported: Identifier;
    loc: SourceLocation | null;
    local: Identifier;
}
Expression <: Node {
    loc: SourceLocation | null;
}
ExpressionStatement <: Statement {
    type: "ExpressionStatement";
    expression: Expression;
    loc: SourceLocation | null;
}
ForInStatement <: Statement {
    type: "ForInStatement";
    left: VariableDeclaration |  Pattern;
    right: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
ForOfStatement <: ForInStatement {
    type: "ForOfStatement";
    await: boolean;
    left: VariableDeclaration |  Pattern;
    right: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
ForStatement <: Statement {
    type: "ForStatement";
    init: VariableDeclaration | Expression | null;
    test: Expression | null;
    update: Expression | null;
    body: Statement;
    loc: SourceLocation | null;
}
Function <: Node {
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
    body: FunctionBody;
    loc: SourceLocation | null;
}
FunctionBody <: BlockStatement {
    body: [ Directive | Statement ];
}
FunctionDeclaration <: Function, Declaration {
    type: "FunctionDeclaration";
    id: Identifier;
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    params: [ Pattern ];
    body: FunctionBody;
}
FunctionExpression <: Function, Expression {
    type: "FunctionExpression";
    loc: SourceLocation | null;
    async: boolean;
    generator: boolean;
    id: Identifier | null;
    params: [ Pattern ];
    body: FunctionBody;
}
Identifier <: Expression, Pattern {
    type: "Identifier";
    name: string;
    loc: SourceLocation | null;
}
IfStatement <: Statement {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate: Statement | null;
    loc: SourceLocation | null;
}
ImportDeclaration <: ModuleDeclaration {
    type: "ImportDeclaration";
    source: Literal;
    specifiers: [ ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier ];
    loc: SourceLocation | null;
}
ImportDefaultSpecifier <: ModuleSpecifier {
    type: "ImportDefaultSpecifier";
    loc: SourceLocation | null;
    local: Identifier;
}
ImportExpression <: Expression {
    type: "ImportExpression";
    source: Expression;
    loc: SourceLocation | null;
}
ImportNamespaceSpecifier <: ModuleSpecifier {
    type: "ImportNamespaceSpecifier";
    loc: SourceLocation | null;
    local: Identifier;
}
ImportSpecifier <: ModuleSpecifier {
    type: "ImportSpecifier";
    imported: Identifier;
    loc: SourceLocation | null;
    local: Identifier;
}
LabeledStatement <: Statement {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
    loc: SourceLocation | null;
}
Literal <: Expression {
    type: "Literal";
    value: string | boolean | null | number | RegExp | bigint;
    loc: SourceLocation | null;
}
LogicalExpression <: Expression {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
    loc: SourceLocation | null;
}
LogicalOperator {
    "||" | "&&" | "??"
}
MemberExpression <: Expression, Pattern, ChainElement {
    type: "MemberExpression";
    object: Expression | Super;
    property: Expression;
    computed: boolean;
    loc: SourceLocation | null;
    optional: boolean;
}
MetaProperty <: Expression {
    type: "MetaProperty";
    meta: Identifier;
    property: Identifier;
    loc: SourceLocation | null;
}
MethodDefinition <: Node {
    type: "MethodDefinition";
    key: Expression;
    value: FunctionExpression;
    kind: "constructor" | "method" | "get" | "set";
    computed: boolean;
    static: boolean;
    loc: SourceLocation | null;
}
ModuleDeclaration <: Node {
    loc: SourceLocation | null;
}
ModuleSpecifier <: Node {
    loc: SourceLocation | null;
    local: Identifier;
}
NewExpression <: Expression {
    type: "NewExpression";
    callee: Expression;
    arguments: [ Expression | SpreadElement ];
    loc: SourceLocation | null;
}
Node {
    loc: SourceLocation | null;
    type: string;
}
ObjectExpression <: Expression {
    type: "ObjectExpression";
    properties: [ Property | SpreadElement ];
    loc: SourceLocation | null;
}
ObjectPattern <: Pattern {
    type: "ObjectPattern";
    properties: [ AssignmentProperty | RestElement ];
    loc: SourceLocation | null;
}
Pattern <: Node {
    loc: SourceLocation | null;
}
Position {
    line: number; // >= 1;
    column: number; // >= 0;
}
Program <: Node {
    type: "Program";
    body: [ Directive | Statement ];
    loc: SourceLocation | null;
}
Property <: Node {
    type: "Property";
    key: Expression;
    method: boolean;
    shorthand: boolean;
    computed: boolean;
    value: Expression;
    kind: "init" | "get" | "set";
    loc: SourceLocation | null;
}
RegExpLiteral <: Literal {
    regex: {
        pattern: string;
        flags: string;
    };
}
RestElement <: Pattern {
    type: "RestElement";
    argument: Pattern;
    loc: SourceLocation | null;
}
ReturnStatement <: Statement {
    type: "ReturnStatement";
    argument: Expression | null;
    loc: SourceLocation | null;
}
SequenceExpression <: Expression {
    type: "SequenceExpression";
    expressions: [ Expression ];
    loc: SourceLocation | null;
}
SourceLocation {
    source: string | null;
    start: Position;
    end: Position;
}
SpreadElement <: Node {
    type: "SpreadElement";
    argument: Expression;
    loc: SourceLocation | null;
}
Statement <: Node {
    loc: SourceLocation | null;
}
Super <: Node {
    type: "Super";
    loc: SourceLocation | null;
}
SwitchCase <: Node {
    type: "SwitchCase";
    test: Expression | null;
    consequent: [ Statement ];
    loc: SourceLocation | null;
}
SwitchStatement <: Statement {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: [ SwitchCase ];
    loc: SourceLocation | null;
}
TaggedTemplateExpression <: Expression {
    type: "TaggedTemplateExpression";
    tag: Expression;
    quasi: TemplateLiteral;
    loc: SourceLocation | null;
}
TemplateElement <: Node {
    type: "TemplateElement";
    tail: boolean;
    value: {
        cooked: string | null;
        raw: string;
    };
    loc: SourceLocation | null;
}
TemplateLiteral <: Expression {
    type: "TemplateLiteral";
    quasis: [ TemplateElement ];
    expressions: [ Expression ];
    loc: SourceLocation | null;
}
ThisExpression <: Expression {
    type: "ThisExpression";
    loc: SourceLocation | null;
}
ThrowStatement <: Statement {
    type: "ThrowStatement";
    argument: Expression;
    loc: SourceLocation | null;
}
TryStatement <: Statement {
    type: "TryStatement";
    block: BlockStatement;
    handler: CatchClause | null;
    finalizer: BlockStatement | null;
    loc: SourceLocation | null;
}
UnaryExpression <: Expression {
    type: "UnaryExpression";
    operator: UnaryOperator;
    prefix: boolean;
    argument: Expression;
    loc: SourceLocation | null;
}
UnaryOperator {
    "-" | "+" | "!" | "~" | "typeof" | "void" | "delete"
}
UpdateExpression <: Expression {
    type: "UpdateExpression";
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
    loc: SourceLocation | null;
}
UpdateOperator {
    "++" | "--"
}
VariableDeclaration <: Declaration {
    type: "VariableDeclaration";
    declarations: [ VariableDeclarator ];
    kind: "var" | "let" | "const";
    loc: SourceLocation | null;
}
VariableDeclarator <: Node {
    type: "VariableDeclarator";
    id: Pattern;
    init: Expression | null;
    loc: SourceLocation | null;
}
WhileStatement <: Statement {
    type: "WhileStatement";
    test: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
WithStatement <: Statement {
    type: "WithStatement";
    object: Expression;
    body: Statement;
    loc: SourceLocation | null;
}
YieldExpression <: Expression {
    type: "YieldExpression";
    argument: Expression | null;
    delegate: boolean;
    loc: SourceLocation | null;
}

*/
